---
title: 字长和内存上限
date: "2019-07-15"
language: zh-CN
category: other
---

> 很多人都知道 CPU 决定了系统可用内存(RAM)的上限，但是这其中的具体的机制是什么呢？

### 程序计数器（Program Counter）

CPU 主要功能是拿取-解释-执行存储在内存中的机器指令，你可能听过 *Fetch-Decode-Execute* 循环，这是 CPU 的工作流程。

在 Fetch 阶段，CPU 内部的 3 个小型存储设备(寄存器)至关重要：

- 程序计数器(Program Counter)，简称 PC，存储的是下一条指令的地址
- 内存地址寄存器(Memory Address Register), 简称 MAR，存储的是当前指令的地址
- 指令寄存器(Instruction Register), 简称 IR，存储的是当前指令

Fetch-Decode-Execute 的流程大致如下：

1. 从 PC 中读取下一条指令的地址
2. 将该地址放入 MAR 中
3. 内存管理器(memory controller) 根据 MAR 找到并读取指令放入 IR 中
4. IR 中的指令被解释并执行
5. PC 更新，指向内存中的下一条指令，回到第 1 步

*为什么要将 PC 的内容复制到 MAR 中，再根据 MAR 找指令呢？直接根据 PC 找不行吗？这是个好问题，但和本文的主题无关，这里不展开。*

从系统通电开始，直到系统断电，程序计数器(PC)不断更新其所存储的指令地址，CPU 根据指令地址找到内存中的指令并执行，程序计数器更新，进入下一次循环。

程序寄存器的存储空间非常小，只有一字长(word size)。因为它存储的是下一条指令的地址，所以它的大小（也即一字长）决定了 CPU 可以访问的内存空间的上限。

### 字长和可寻址空间

假设一台计算机的字长是 1 比特，那么程序计数器可能存储的地址集合为：[0, 1]。字长是 2 比特呢? 4 个：[00, 01, 10, 11]。...

由此可见，如果字长是 n 比特，程序计数器可能存储的地址集合的 size 为 2^n。专业点的说法是，可寻址空间为 2^n 个。

从逻辑上来说，内存是个线性的字节数组，每个地址都代表一个字节的存储空间。

这样以来，字长是 n 比特的计算机，有效内存的上限是 2^n 字节。

### 32 位和 64 位计算机

经常听说买电脑要买 64 位的，这里的 64 就是指的是字长为 64 位。在写这篇博客之时(2019年)，市面上的电脑大多都是 64 位的了，但还是有部分服务器是 32 位。

32 位计算机有效内存上限是 2^32 字节，也就是 4 GB (1GB = 2^30 Byte)，在应用体积越来越大的今天显然不够用。而 64 位计算机有效内存上限是 2^64 字节，也就是 2^24 TB, 即使未来应用体积持续膨胀也不大可能达到 TB 量级，更别提 2^24 TB 了。

所以未来我们需要 128 位的计算机了吗？至少从内存上限的角度来看，大概率用不到。
