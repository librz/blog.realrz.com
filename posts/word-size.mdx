---
title: 字长和内存上限
date: "2019-07-15"
language: zh-CN
category: other
---

> 很多人都知道自己电脑的 CPU 是 64 位的，但这意味着什么呢？以前我们由 32 位 CPU 过渡到 64 位的，那未来会不会需要换成 128 位的呢？这篇文章会解释这些问题。

### 程序计数器（Program Counter）

CPU的主要功能是不断执行存储在内存中的机器指令，你可能听过 *Fetch-Decode-Execute* 循环，这是 CPU 的工作流程。

在 Fetch 阶段，CPU 内部的 3 个小型存储设备(寄存器)至关重要：

- 程序计数器(Program Counter)，简称 PC，存储的是下一条指令的地址
- 内存地址寄存器(Memory Address Register), 简称 MAR，存储的是当前指令的地址
- 指令寄存器(Instruction Register), 简称 IR，存储的是当前指令

Fetch-Decode-Execute 的流程大致如下：

1. 从 PC 中读取下一条指令的地址
2. 将该地址放入 MAR 中
3. 内存管理器(memory controller) 根据 MAR 找到并读取指令放入 IR 中
4. IR 中的指令被解释并执行
5. PC 更新，指向内存中的下一条指令，回到第 1 步

*为什么要将 PC 的内容复制到 MAR 中，再根据 MAR 找指令呢？直接根据 PC 找不行吗？这是个好问题，但和本文的主题无关，这里不展开。*

从系统通电开始，直到系统断电，程序计数器(PC)不断更新其所存储的指令地址，CPU 根据指令地址找到内存中的指令并执行，程序计数器更新，进入下一次循环。

程序寄存器的存储空间非常小，只有一字长(word size)。因为它存储的是下一条指令的地址，所以它的大小（也即一字长）决定了 CPU 可以访问的内存空间的上限。

### 字长和可寻址空间

假设一台计算机的字长是 1 比特，那么程序计数器可能存储的地址集合为：[0, 1]。字长是 2 比特呢? 4 个：[00, 01, 10, 11]。...

由此可见，如果字长是 n 比特，程序计数器可能存储的地址集合的 size 为 2^n。专业点的说法是，可寻址空间为 2^n 个。

从逻辑上来说，内存是个线性的字节数组，每个地址都代表一个字节的存储空间。

这样以来，字长是 n 比特的计算机，有效内存的上限是 2^n 字节。

### 嵌入式系统的CPU

由于资源限制和成本考量，嵌入式系统的CPU(一般叫做 MCU, Microcontroller Unit)通常字长比较小，比如 8 位、16 位和 32 位。

- 8 位 CPU 的内存上限是 2^8 = 256 字节，常见的 8051 就是 8 位的，你可能听说过51单片机，它的名字就来源于此。
- 16 位 CPU 的内存上限是 2^16 = 64 KB
- 32 位 CPU 的内存上限是 2^32 = 4 GB，32 位 CPU 对于嵌入式系统来说已经是高端了，一般会在上面运行裁剪过的 Linux 系统。你可能听说过 STM32，它泛指的是一系列 32 位微控制器(比如著名的 ARM-Cortex-M 系列)。

### 32 位和 64 位计算机

经常听说买电脑要买 64 位的，这里的 64 就是指的是字长为 64 位。在写这篇博客之时(2019年)，市面上的电脑大多都是 64 位的了，但还是有部分服务器是 32 位。手机方面，2013 年发布的 iPhone 5s 采用的是 ARM Cortex-A7，它是首款 64 位手机芯片。

32 位计算机有效内存上限是 2^32 字节，也就是 4 GB (1GB = 2^30 Byte)，在应用体积越来越大的今天显然不够用。而 64 位计算机有效内存上限是 2^64 字节，也就是 2^24 TB, 即使未来应用体积持续膨胀也不大可能达到 TB 量级，更别提 2^24 TB 了。

所以未来我们需要 128 位的计算机了吗？至少从内存上限的角度来看，大概率用不到。
